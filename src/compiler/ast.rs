//! The AST module contains the AST node types and related types.
//!
//! An AST (Abstract Syntax Tree) is a tree-like structure that represents the structure of a program.
//! It is a broken down version of source code that represents the heirarchical and functional structure.
//!
//! Here, the entire AST for a script is represented by a single [`AstNode`], generated by the
//! [parser](`crate::compiler::parser`). The AST is translated into bytecode by the
//! [translator](`crate::compiler::translator`), and then executed by the [executor](`crate::runtime::executor`).

use serde::{Deserialize, Serialize};

/// A big enum of every possible type of node in the AST.
///
/// This is a recursive enum, meaning that some variant can contain other variants.
/// It is possible to use this enum to represent the entire AST of a program.
///
/// Note: The root node of an AST is usually a [`Block`] (a collection of statement nodes),
/// as this is generated by the parser, but the [`crate::runtime::executor`] does not have this requirement.
#[derive(Debug, Clone)]
pub enum AstNode {
    // ============== Expressions ==============
    // -------------- Values --------------
    /// An identifier representing a variable stored in some scope.
    /// Holds the name of the variable.
    Identifier(String),
    /// A literal number. Holds the value of the number.
    NumberLiteral(Number),
    /// A literal nil.
    NilLiteral,
    /// A literal string. Holds the value of the string.
    StringLiteral(String),
    /// A literal boolean. Holds the value of the boolean.
    BooleanLiteral(bool),
    // -------------- Operations --------------
    /// A unary operation.
    UnaryOperation {
        /// The operation kind.
        kind: UnaryOperationKind,
        /// The target of the operation.
        operand: Box<AstNode>,
    },
    /// A binary operation.
    BinaryOperation {
        /// The operation kind.
        kind: BinaryOperationKind,
        /// The left operand.
        left: Box<AstNode>,
        /// The right operand.
        right: Box<AstNode>,
    },
    // -------------- Functions --------------
    /// A function call.
    FunctionCall {
        /// Name of the function to call. Will be loaded from the current scope or a parent scope.
        identifier: String,
        /// Arguments to pass to the function.
        args: Vec<AstNode>,
    },
    /// A function definition.
    FunctionDef {
        /// Arguments taken by the function. Should technically be called parameters, but whatever :D
        args: Vec<String>,
        /// The body of the function.
        body: Box<AstNode>,
    },
    // ============== Statements ==============
    // -------------- Misc --------------
    /// Assignment to a variable in the local scope.
    Assignment {
        /// The name of the variable to assign to.
        identifier: String,
        /// The value to assign to the variable.
        value: Box<AstNode>,
    },
    /// A collection of back-to-back statements.
    Block(Vec<AstNode>),
    // -------------- Control Flow --------------
    /// An if statement. `If` nodes only contain "if" or "else" blocks for simplicity.
    /// An else-if block can be formed with nested if statements.
    If {
        /// The condition evaluated to determine which block to run
        condition: Box<AstNode>,
        /// The "then" block
        body: Box<AstNode>,
        /// The "else" block
        else_body: Option<Box<AstNode>>,
    },
    // A for loop. The for loop takes on the C form: `for (initialization; condition; increment) { body }`.
    For {
        /// The initialization statement. This is run before the loop starts.
        /// It may be omitted to not run any initialization.
        initialization: Option<Box<AstNode>>,
        /// The condition statement. This is run before each iteration of the loop.
        /// This may be omitted to run the loop forever, or until broken.
        condition: Option<Box<AstNode>>,
        /// The increment statement. This is run after each iteration of the loop.
        /// This may be omitted to not run any increment.
        increment: Option<Box<AstNode>>,
        /// The body of the loop.
        body: Box<AstNode>,
    },
    /// A while loop.
    While {
        /// The condition evaluated before each iteration.
        condition: Box<AstNode>,
        /// The body of the loop.
        body: Box<AstNode>,
    },
    /// An infinite loop.
    Loop {
        /// The body of the loop.
        body: Box<AstNode>,
    },
    /// A break statement.
    Break,
    /// A continue statement.
    Continue,
    /// A return statement.
    Return {
        /// The value to return (optional).
        value: Option<Box<AstNode>>,
    },
}

/// The type of a unary operation.
#[derive(Debug, Clone, Copy, Eq, PartialEq, Serialize, Deserialize)]
pub enum UnaryOperationKind {
    Negate,
    Not,
}

impl UnaryOperationKind {
    /// Returns the dunder method name for this operation.
    ///
    /// Currently unused. This may be used for implementing operator
    /// overloading in the future.
    pub fn dunder(&self) -> String {
        match self {
            UnaryOperationKind::Negate => "__neg__",
            UnaryOperationKind::Not => "__not__",
        }
        .to_string()
    }
}

/// The type of a binary operation.
#[derive(Debug, Clone, Copy, Eq, PartialEq, Serialize, Deserialize)]
pub enum BinaryOperationKind {
    Add,
    Subtract,
    Multiply,
    Divide,
    Remainder,
    Power,
    And,
    Or,
    Equal,
    NotEqual,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
}

impl BinaryOperationKind {
    /// Returns the dunder method name for this operation.
    ///
    /// Currently unused. This may be used for implementing operator
    /// overloading in the future.
    pub fn dunder(&self) -> String {
        match self {
            BinaryOperationKind::Add => "__add__",
            BinaryOperationKind::Subtract => "__sub__",
            BinaryOperationKind::Multiply => "__mul__",
            BinaryOperationKind::Divide => "__div__",
            BinaryOperationKind::Remainder => "__rem__",
            BinaryOperationKind::Power => "__pow__",
            BinaryOperationKind::And => "__and__",
            BinaryOperationKind::Or => "__or__",
            BinaryOperationKind::Equal => "__eq__",
            BinaryOperationKind::NotEqual => "__ne__",
            BinaryOperationKind::GreaterThan => "__gt__",
            BinaryOperationKind::GreaterThanOrEqual => "__ge__",
            BinaryOperationKind::LessThan => "__lt__",
            BinaryOperationKind::LessThanOrEqual => "__le__",
        }
        .to_string()
    }
}

/// Holds either an integer or float value.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum Number {
    Integer(i64),
    Float(f64),
}
